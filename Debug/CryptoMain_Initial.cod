; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\chenj\OneDrive\Documents\Visual Studio 2013\Projects\Team_06_CS3843_Project\Team_06_CS3843_Project\CryptoMain_Initial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?gkey@@3PAEA					; gkey
PUBLIC	?gptrKey@@3PAEA					; gptrKey
PUBLIC	?gPassword@@3PADA				; gPassword
PUBLIC	?gPasswordHash@@3PAEA				; gPasswordHash
PUBLIC	?gptrPasswordHash@@3PAEA			; gptrPasswordHash
PUBLIC	?gdebug1@@3EA					; gdebug1
PUBLIC	?gdebug2@@3EA					; gdebug2
PUBLIC	?gfptrIn@@3PAU_iobuf@@A				; gfptrIn
PUBLIC	?gfptrOut@@3PAU_iobuf@@A			; gfptrOut
PUBLIC	?gfptrKey@@3PAU_iobuf@@A			; gfptrKey
PUBLIC	?gInFileName@@3PADA				; gInFileName
PUBLIC	?gOutFileName@@3PADA				; gOutFileName
PUBLIC	?gKeyFileName@@3PADA				; gKeyFileName
PUBLIC	?gOp@@3HA					; gOp
PUBLIC	?gNumRounds@@3HA				; gNumRounds
PUBLIC	?gEncodeTable@@3PAEA				; gEncodeTable
PUBLIC	?gDecodeTable@@3PAEA				; gDecodeTable
_BSS	SEGMENT
?gkey@@3PAEA DB	010001H DUP (?)				; gkey
	ALIGN	4

?gPasswordHash@@3PAEA DB 020H DUP (?)			; gPasswordHash
?gdebug1@@3EA DB 01H DUP (?)				; gdebug1
	ALIGN	4

?gdebug2@@3EA DB 01H DUP (?)				; gdebug2
	ALIGN	4

?gfptrIn@@3PAU_iobuf@@A DD 01H DUP (?)			; gfptrIn
?gfptrOut@@3PAU_iobuf@@A DD 01H DUP (?)			; gfptrOut
?gfptrKey@@3PAU_iobuf@@A DD 01H DUP (?)			; gfptrKey
?gInFileName@@3PADA DB 0100H DUP (?)			; gInFileName
?gOutFileName@@3PADA DB 0100H DUP (?)			; gOutFileName
?gKeyFileName@@3PADA DB 0100H DUP (?)			; gKeyFileName
?gOp@@3HA DD	01H DUP (?)				; gOp
_BSS	ENDS
_DATA	SEGMENT
?gptrKey@@3PAEA DD FLAT:?gkey@@3PAEA			; gptrKey
?gptrPasswordHash@@3PAEA DD FLAT:?gPasswordHash@@3PAEA	; gptrPasswordHash
?gPassword@@3PADA DB 'password', 00H			; gPassword
	ORG $+247
?gNumRounds@@3HA DD 01H					; gNumRounds
	ORG $+4
?gEncodeTable@@3PAEA DB 027H				; gEncodeTable
	DB	046H
	DB	017H
	DB	07H
	DB	03cH
	DB	0ffH
	DB	03fH
	DB	0d3H
	DB	04cH
	DB	0b2H
	DB	0c1H
	DB	0c3H
	DB	05fH
	DB	015H
	DB	04H
	DB	0efH
	DB	038H
	DB	0aeH
	DB	0eH
	DB	097H
	DB	02dH
	DB	04dH
	DB	0f8H
	DB	0c2H
	DB	035H
	DB	0daH
	DB	09fH
	DB	024H
	DB	043H
	DB	050H
	DB	09dH
	DB	045H
	DB	0d2H
	DB	0aH
	DB	078H
	DB	0e0H
	DB	03eH
	DB	018H
	DB	089H
	DB	062H
	DB	0c7H
	DB	07fH
	DB	093H
	DB	0ceH
	DB	0b4H
	DB	031H
	DB	07bH
	DB	0ccH
	DB	00H
	DB	0dbH
	DB	010H
	DB	092H
	DB	05dH
	DB	0f4H
	DB	077H
	DB	08aH
	DB	02cH
	DB	0a9H
	DB	034H
	DB	0faH
	DB	026H
	DB	01cH
	DB	0f6H
	DB	0a4H
	DB	095H
	DB	06cH
	DB	04bH
	DB	0c4H
	DB	09H
	DB	05aH
	DB	074H
	DB	0ecH
	DB	06aH
	DB	0afH
	DB	04aH
	DB	084H
	DB	063H
	DB	0dH
	DB	0aaH
	DB	014H
	DB	030H
	DB	016H
	DB	064H
	DB	06dH
	DB	058H
	DB	0d0H
	DB	0bbH
	DB	0d8H
	DB	075H
	DB	0e5H
	DB	02aH
	DB	09bH
	DB	041H
	DB	0c8H
	DB	08dH
	DB	0e6H
	DB	01H
	DB	0b1H
	DB	0a0H
	DB	0f3H
	DB	0ebH
	DB	09eH
	DB	069H
	DB	087H
	DB	037H
	DB	081H
	DB	048H
	DB	07cH
	DB	0a8H
	DB	0c0H
	DB	0f5H
	DB	0b7H
	DB	023H
	DB	0a3H
	DB	07eH
	DB	02eH
	DB	0e4H
	DB	01dH
	DB	056H
	DB	033H
	DB	03dH
	DB	0a5H
	DB	0e3H
	DB	0d1H
	DB	0bfH
	DB	055H
	DB	022H
	DB	0c6H
	DB	0c9H
	DB	0dfH
	DB	032H
	DB	09cH
	DB	0fdH
	DB	0d6H
	DB	03H
	DB	06H
	DB	05cH
	DB	08eH
	DB	0b0H
	DB	03bH
	DB	08cH
	DB	036H
	DB	04fH
	DB	02H
	DB	025H
	DB	07aH
	DB	0edH
	DB	07dH
	DB	0d5H
	DB	082H
	DB	011H
	DB	090H
	DB	0bH
	DB	0cdH
	DB	0b3H
	DB	0abH
	DB	02bH
	DB	053H
	DB	0b6H
	DB	054H
	DB	0a2H
	DB	0e8H
	DB	059H
	DB	072H
	DB	086H
	DB	083H
	DB	0caH
	DB	049H
	DB	06eH
	DB	040H
	DB	0bcH
	DB	061H
	DB	052H
	DB	0feH
	DB	079H
	DB	0eaH
	DB	029H
	DB	042H
	DB	088H
	DB	096H
	DB	0beH
	DB	012H
	DB	0cbH
	DB	0baH
	DB	08H
	DB	01eH
	DB	051H
	DB	02fH
	DB	044H
	DB	020H
	DB	065H
	DB	06bH
	DB	04eH
	DB	067H
	DB	0eeH
	DB	0a6H
	DB	071H
	DB	0dcH
	DB	076H
	DB	019H
	DB	0deH
	DB	0f2H
	DB	0fbH
	DB	070H
	DB	021H
	DB	0cfH
	DB	073H
	DB	068H
	DB	0e7H
	DB	0b9H
	DB	0f1H
	DB	05bH
	DB	091H
	DB	0d9H
	DB	0d4H
	DB	099H
	DB	01bH
	DB	0e1H
	DB	0f0H
	DB	0ddH
	DB	0fcH
	DB	0e2H
	DB	039H
	DB	05eH
	DB	01aH
	DB	066H
	DB	060H
	DB	0a7H
	DB	08bH
	DB	0b8H
	DB	0d7H
	DB	094H
	DB	0e9H
	DB	0acH
	DB	0c5H
	DB	09aH
	DB	0bdH
	DB	06fH
	DB	0f9H
	DB	028H
	DB	013H
	DB	05H
	DB	057H
	DB	0b5H
	DB	0cH
	DB	080H
	DB	08fH
	DB	03aH
	DB	01fH
	DB	047H
	DB	098H
	DB	0fH
	DB	0f7H
	DB	0adH
	DB	085H
	DB	0a1H
?gDecodeTable@@3PAEA DB 030H				; gDecodeTable
	DB	060H
	DB	08fH
	DB	086H
	DB	0eH
	DB	0f1H
	DB	087H
	DB	03H
	DB	0b8H
	DB	044H
	DB	021H
	DB	098H
	DB	0f4H
	DB	04dH
	DB	012H
	DB	0fbH
	DB	032H
	DB	096H
	DB	0b5H
	DB	0f0H
	DB	04fH
	DB	0dH
	DB	051H
	DB	02H
	DB	025H
	DB	0c7H
	DB	0e0H
	DB	0d8H
	DB	03dH
	DB	075H
	DB	0b9H
	DB	0f8H
	DB	0bdH
	DB	0ccH
	DB	07eH
	DB	070H
	DB	01bH
	DB	090H
	DB	03cH
	DB	00H
	DB	0efH
	DB	0b0H
	DB	05aH
	DB	09cH
	DB	038H
	DB	014H
	DB	073H
	DB	0bbH
	DB	050H
	DB	02dH
	DB	082H
	DB	077H
	DB	03aH
	DB	018H
	DB	08dH
	DB	068H
	DB	010H
	DB	0deH
	DB	0f7H
	DB	08bH
	DB	04H
	DB	078H
	DB	024H
	DB	06H
	DB	0a9H
	DB	05cH
	DB	0b1H
	DB	01cH
	DB	0bcH
	DB	01fH
	DB	01H
	DB	0f9H
	DB	06aH
	DB	0a7H
	DB	04aH
	DB	042H
	DB	08H
	DB	015H
	DB	0c0H
	DB	08eH
	DB	01dH
	DB	0baH
	DB	0acH
	DB	09dH
	DB	09fH
	DB	07dH
	DB	076H
	DB	0f2H
	DB	054H
	DB	0a2H
	DB	045H
	DB	0d3H
	DB	088H
	DB	034H
	DB	0dfH
	DB	0cH
	DB	0e2H
	DB	0abH
	DB	027H
	DB	04cH
	DB	052H
	DB	0beH
	DB	0e1H
	DB	0c1H
	DB	0cfH
	DB	066H
	DB	048H
	DB	0bfH
	DB	041H
	DB	053H
	DB	0a8H
	DB	0edH
	DB	0cbH
	DB	0c4H
	DB	0a3H
	DB	0ceH
	DB	046H
	DB	058H
	DB	0c6H
	DB	036H
	DB	022H
	DB	0aeH
	DB	091H
	DB	02eH
	DB	06bH
	DB	093H
	DB	072H
	DB	029H
	DB	0f5H
	DB	069H
	DB	095H
	DB	0a5H
	DB	04bH
	DB	0feH
	DB	0a4H
	DB	067H
	DB	0b2H
	DB	026H
	DB	037H
	DB	0e4H
	DB	08cH
	DB	05eH
	DB	089H
	DB	0f6H
	DB	097H
	DB	0d4H
	DB	033H
	DB	02aH
	DB	0e7H
	DB	040H
	DB	0b3H
	DB	013H
	DB	0faH
	DB	0d7H
	DB	0ebH
	DB	05bH
	DB	083H
	DB	01eH
	DB	065H
	DB	01aH
	DB	062H
	DB	0ffH
	DB	0a0H
	DB	071H
	DB	03fH
	DB	079H
	DB	0c3H
	DB	0e3H
	DB	06cH
	DB	039H
	DB	04eH
	DB	09bH
	DB	0e9H
	DB	0fdH
	DB	011H
	DB	049H
	DB	08aH
	DB	061H
	DB	09H
	DB	09aH
	DB	02cH
	DB	0f3H
	DB	09eH
	DB	06fH
	DB	0e5H
	DB	0d1H
	DB	0b7H
	DB	056H
	DB	0aaH
	DB	0ecH
	DB	0b4H
	DB	07cH
	DB	06dH
	DB	0aH
	DB	017H
	DB	0bH
	DB	043H
	DB	0eaH
	DB	07fH
	DB	028H
	DB	05dH
	DB	080H
	DB	0a6H
	DB	0b6H
	DB	02fH
	DB	099H
	DB	02bH
	DB	0cdH
	DB	055H
	DB	07bH
	DB	020H
	DB	07H
	DB	0d6H
	DB	094H
	DB	085H
	DB	0e6H
	DB	057H
	DB	0d5H
	DB	019H
	DB	031H
	DB	0c5H
	DB	0dbH
	DB	0c8H
	DB	081H
	DB	023H
	DB	0d9H
	DB	0ddH
	DB	07aH
	DB	074H
	DB	059H
	DB	05fH
	DB	0d0H
	DB	0a1H
	DB	0e8H
	DB	0afH
	DB	064H
	DB	047H
	DB	092H
	DB	0c2H
	DB	0fH
	DB	0daH
	DB	0d2H
	DB	0c9H
	DB	063H
	DB	035H
	DB	06eH
	DB	03eH
	DB	0fcH
	DB	016H
	DB	0eeH
	DB	03bH
	DB	0caH
	DB	0dcH
	DB	084H
	DB	0adH
	DB	05H
_DATA	ENDS
PUBLIC	?exCountLetters@@YAXPADHPAH11@Z			; exCountLetters
PUBLIC	?encryptFile@@YAHPAU_iobuf@@0@Z			; encryptFile
PUBLIC	?decryptFile@@YAHPAU_iobuf@@0@Z			; decryptFile
PUBLIC	?openInputFile@@YAPAU_iobuf@@PAD@Z		; openInputFile
PUBLIC	?openOutputFile@@YAPAU_iobuf@@PAD@Z		; openOutputFile
PUBLIC	?usage@@YAXQAPAD@Z				; usage
PUBLIC	?parseCommandLine@@YAXHQAPAD@Z			; parseCommandLine
PUBLIC	_main
PUBLIC	??_C@_0CA@JAEAEOCO@Error?5?9?5Input?5file?5too?5large?4?6?6?$AA@ ; `string'
PUBLIC	??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5by@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0CK@CDMOMEJ@?6?6Error?5?9?5Could?5not?5open?5input?5f@ ; `string'
PUBLIC	??_C@_03BFHAFKOB@wb?$CL?$AA@			; `string'
PUBLIC	??_C@_0CL@DAJOHFLE@?6?6Error?5?9?5Could?5not?5open?5output?5@ ; `string'
PUBLIC	??_C@_0L@HKODOBAD@?6?6Usage?3?6?6?$AA@		; `string'
PUBLIC	??_C@_0N@MOPCGLHN@To?5Encrypt?3?6?$AA@		; `string'
PUBLIC	??_C@_0EF@JJIJOCMP@?$CFs?5?9e?5?$DMmessage_filename?$DO?5?9k?5?$DMkey@ ; `string'
PUBLIC	??_C@_0N@KDGFJOJO@To?5Decrypt?3?6?$AA@		; `string'
PUBLIC	??_C@_0EF@BJGDLACJ@?$CFs?5?9d?5?$DMmessage_filename?$DO?5?9k?5?$DMkey@ ; `string'
PUBLIC	??_C@_0CK@PGOBLBKL@?9e?5filename?7?7?3encrypt?5the?5specif@ ; `string'
PUBLIC	??_C@_0CK@GOFFCHFO@?9d?5filename?7?7?3decrypt?5the?5specif@ ; `string'
PUBLIC	??_C@_0EL@OBNDFCCB@?9p?5password?7?7?3the?5password?5to?5be@ ; `string'
PUBLIC	??_C@_0ED@MAGAAIDD@?9r?5?$DM?$CDrounds?$DO?7?7?3number?5of?5encrypt@ ; `string'
PUBLIC	??_C@_0FE@LAODCPP@?9o?5filename?7?7?3name?5of?5the?5output@ ; `string'
PUBLIC	??_C@_0CK@IPLMHCJC@The?5order?5of?5the?5options?5is?5irre@ ; `string'
PUBLIC	??_C@_0CO@BHBEBKEC@All?5options?5must?5be?5preceeded?5by@ ; `string'
PUBLIC	??_C@_0FA@LMDBBGLK@Error?$CB?5Already?5specifed?5an?5input@ ; `string'
PUBLIC	??_C@_0CM@IFNFECJC@Error?$CB?5Must?5specify?5a?5filename?5a@ ; `string'
PUBLIC	??_C@_0FA@FBLKPEDD@Error?$CB?5Already?5specifed?5an?5input@ ; `string'
PUBLIC	??_C@_0CM@LILFGLCC@Error?$CB?5Must?5specify?5a?5filename?5a@ ; `string'
PUBLIC	??_C@_0CK@OMLLAEKC@Error?$CB?5Already?5specifed?5an?5outpu@ ; `string'
PUBLIC	??_C@_0CM@MPGFFKDD@Error?$CB?5Must?5specify?5a?5filename?5a@ ; `string'
PUBLIC	??_C@_0CG@EICJBIPF@Error?$CB?5Already?5specifed?5a?5key?5fi@ ; `string'
PUBLIC	??_C@_0CM@DKOFPMPD@Error?$CB?5Must?5specify?5a?5filename?5a@ ; `string'
PUBLIC	??_C@_0CG@OPKIBCL@Error?$CB?5Already?5specifed?5a?5passwo@ ; `string'
PUBLIC	??_C@_0CK@LDPPFIPG@Error?$CB?5Must?5enter?5a?5password?5aft@ ; `string'
PUBLIC	??_C@_0DG@KLPKKKEI@Error?$CB?5Must?5enter?5number?5between@ ; `string'
PUBLIC	??_C@_0EG@DAMCJAK@Warning?$CB?5Entered?5bad?5value?5for?5n@ ; `string'
PUBLIC	??_C@_0CI@KGFPEMBM@Error?$CB?5Illegal?5option?5in?5argumen@ ; `string'
PUBLIC	??_C@_0DA@HLBMPEJP@Error?$CB?5Encrypt?5or?5Decrypt?5must?5b@ ; `string'
PUBLIC	??_C@_0CC@GEEGHLPK@Error?$CB?5No?5input?5file?5specified?4?6@ ; `string'
PUBLIC	??_C@_0CA@JJGKKPID@Error?$CB?5No?5key?5file?5specified?4?6?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@NMMOLMAM@Warning?$CB?5Using?5default?5?8password@ ; `string'
PUBLIC	??_C@_04EHENEAPI@?4enc?$AA@			; `string'
PUBLIC	??_C@_04PDKEMIHM@?4dec?$AA@			; `string'
PUBLIC	??_C@_06LPALFHPD@ABCDE?$AA?$AA@			; `string'
PUBLIC	??_C@_0BE@ILNEECEA@?6?6Crypto?5Order?3?$CFs?6?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@KLALAHPJ@Error?$CB?5Password?5not?5hashed?5corre@ ; `string'
PUBLIC	??_C@_0DD@EONHCAAK@Error?$CB?5Length?5of?5key?5file?5is?5not@ ; `string'
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_strncpy:PROC
EXTRN	_exit:PROC
EXTRN	_atoi:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	___iob_func:PROC
EXTRN	_fclose:PROC
EXTRN	__fileno:PROC
EXTRN	_fopen:PROC
EXTRN	_fprintf:PROC
EXTRN	_fread:PROC
EXTRN	_fwrite:PROC
EXTRN	_printf:PROC
EXTRN	__filelength:PROC
EXTRN	?sha256@@YAHPAD0KQAE@Z:PROC			; sha256
EXTRN	?encryptData@@YAHPADH@Z:PROC			; encryptData
EXTRN	?decryptData@@YAHPADH@Z:PROC			; decryptData
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0DD@EONHCAAK@Error?$CB?5Length?5of?5key?5file?5is?5not@
CONST	SEGMENT
??_C@_0DD@EONHCAAK@Error?$CB?5Length?5of?5key?5file?5is?5not@ DB 'Error! '
	DB	'Length of key file is not at least 65537.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KLALAHPJ@Error?$CB?5Password?5not?5hashed?5corre@
CONST	SEGMENT
??_C@_0CI@KLALAHPJ@Error?$CB?5Password?5not?5hashed?5corre@ DB 'Error! Pa'
	DB	'ssword not hashed correctly.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ILNEECEA@?6?6Crypto?5Order?3?$CFs?6?6?$AA@
CONST	SEGMENT
??_C@_0BE@ILNEECEA@?6?6Crypto?5Order?3?$CFs?6?6?$AA@ DB 0aH, 0aH, 'Crypto'
	DB	' Order:%s', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LPALFHPD@ABCDE?$AA?$AA@
CONST	SEGMENT
??_C@_06LPALFHPD@ABCDE?$AA?$AA@ DB 'ABCDE', 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PDKEMIHM@?4dec?$AA@
CONST	SEGMENT
??_C@_04PDKEMIHM@?4dec?$AA@ DB '.dec', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EHENEAPI@?4enc?$AA@
CONST	SEGMENT
??_C@_04EHENEAPI@?4enc?$AA@ DB '.enc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NMMOLMAM@Warning?$CB?5Using?5default?5?8password@
CONST	SEGMENT
??_C@_0CF@NMMOLMAM@Warning?$CB?5Using?5default?5?8password@ DB 'Warning! '
	DB	'Using default ''password''.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JJGKKPID@Error?$CB?5No?5key?5file?5specified?4?6?6?$AA@
CONST	SEGMENT
??_C@_0CA@JJGKKPID@Error?$CB?5No?5key?5file?5specified?4?6?6?$AA@ DB 'Err'
	DB	'or! No key file specified.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GEEGHLPK@Error?$CB?5No?5input?5file?5specified?4?6@
CONST	SEGMENT
??_C@_0CC@GEEGHLPK@Error?$CB?5No?5input?5file?5specified?4?6@ DB 'Error! '
	DB	'No input file specified.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HLBMPEJP@Error?$CB?5Encrypt?5or?5Decrypt?5must?5b@
CONST	SEGMENT
??_C@_0DA@HLBMPEJP@Error?$CB?5Encrypt?5or?5Decrypt?5must?5b@ DB 'Error! E'
	DB	'ncrypt or Decrypt must be specified.', 0aH, 0aH, ')', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KGFPEMBM@Error?$CB?5Illegal?5option?5in?5argumen@
CONST	SEGMENT
??_C@_0CI@KGFPEMBM@Error?$CB?5Illegal?5option?5in?5argumen@ DB 'Error! Il'
	DB	'legal option in argument. %s', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@DAMCJAK@Warning?$CB?5Entered?5bad?5value?5for?5n@
CONST	SEGMENT
??_C@_0EG@DAMCJAK@Warning?$CB?5Entered?5bad?5value?5for?5n@ DB 'Warning! '
	DB	'Entered bad value for number of rounds. Setting it to one.', 0aH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KLPKKKEI@Error?$CB?5Must?5enter?5number?5between@
CONST	SEGMENT
??_C@_0DG@KLPKKKEI@Error?$CB?5Must?5enter?5number?5between@ DB 'Error! Mu'
	DB	'st enter number between 1 and 3 after ''-r''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LDPPFIPG@Error?$CB?5Must?5enter?5a?5password?5aft@
CONST	SEGMENT
??_C@_0CK@LDPPFIPG@Error?$CB?5Must?5enter?5a?5password?5aft@ DB 'Error! M'
	DB	'ust enter a password after ''-p''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OPKIBCL@Error?$CB?5Already?5specifed?5a?5passwo@
CONST	SEGMENT
??_C@_0CG@OPKIBCL@Error?$CB?5Already?5specifed?5a?5passwo@ DB 'Error! Alr'
	DB	'eady specifed a password.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DKOFPMPD@Error?$CB?5Must?5specify?5a?5filename?5a@
CONST	SEGMENT
??_C@_0CM@DKOFPMPD@Error?$CB?5Must?5specify?5a?5filename?5a@ DB 'Error! M'
	DB	'ust specify a filename after ''-k''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EICJBIPF@Error?$CB?5Already?5specifed?5a?5key?5fi@
CONST	SEGMENT
??_C@_0CG@EICJBIPF@Error?$CB?5Already?5specifed?5a?5key?5fi@ DB 'Error! A'
	DB	'lready specifed a key file.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MPGFFKDD@Error?$CB?5Must?5specify?5a?5filename?5a@
CONST	SEGMENT
??_C@_0CM@MPGFFKDD@Error?$CB?5Must?5specify?5a?5filename?5a@ DB 'Error! M'
	DB	'ust specify a filename after ''-o''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OMLLAEKC@Error?$CB?5Already?5specifed?5an?5outpu@
CONST	SEGMENT
??_C@_0CK@OMLLAEKC@Error?$CB?5Already?5specifed?5an?5outpu@ DB 'Error! Al'
	DB	'ready specifed an output file.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LILFGLCC@Error?$CB?5Must?5specify?5a?5filename?5a@
CONST	SEGMENT
??_C@_0CM@LILFGLCC@Error?$CB?5Must?5specify?5a?5filename?5a@ DB 'Error! M'
	DB	'ust specify a filename after ''-d''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@FBLKPEDD@Error?$CB?5Already?5specifed?5an?5input@
CONST	SEGMENT
??_C@_0FA@FBLKPEDD@Error?$CB?5Already?5specifed?5an?5input@ DB 'Error! Al'
	DB	'ready specifed an input file - can''t decrypt/encrypt multipl'
	DB	'e files.', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IFNFECJC@Error?$CB?5Must?5specify?5a?5filename?5a@
CONST	SEGMENT
??_C@_0CM@IFNFECJC@Error?$CB?5Must?5specify?5a?5filename?5a@ DB 'Error! M'
	DB	'ust specify a filename after ''-e''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@LMDBBGLK@Error?$CB?5Already?5specifed?5an?5input@
CONST	SEGMENT
??_C@_0FA@LMDBBGLK@Error?$CB?5Already?5specifed?5an?5input@ DB 'Error! Al'
	DB	'ready specifed an input file - can''t encrypt/decrypt multipl'
	DB	'e files.', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BHBEBKEC@All?5options?5must?5be?5preceeded?5by@
CONST	SEGMENT
??_C@_0CO@BHBEBKEC@All?5options?5must?5be?5preceeded?5by@ DB 'All options'
	DB	' must be preceeded by a dash ''-''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IPLMHCJC@The?5order?5of?5the?5options?5is?5irre@
CONST	SEGMENT
??_C@_0CK@IPLMHCJC@The?5order?5of?5the?5options?5is?5irre@ DB 'The order '
	DB	'of the options is irrelevant.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@LAODCPP@?9o?5filename?7?7?3name?5of?5the?5output@
CONST	SEGMENT
??_C@_0FE@LAODCPP@?9o?5filename?7?7?3name?5of?5the?5output@ DB '-o filena'
	DB	'me', 09H, 09H, ':name of the output file [default=''encrypted'
	DB	'.txt'' or ''decrypted.txt''', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@MAGAAIDD@?9r?5?$DM?$CDrounds?$DO?7?7?3number?5of?5encrypt@
CONST	SEGMENT
??_C@_0ED@MAGAAIDD@?9r?5?$DM?$CDrounds?$DO?7?7?3number?5of?5encrypt@ DB '-'
	DB	'r <#rounds>', 09H, 09H, ':number of encryption rounds (1 - 3)'
	DB	'  [default = 1]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@OBNDFCCB@?9p?5password?7?7?3the?5password?5to?5be@
CONST	SEGMENT
??_C@_0EL@OBNDFCCB@?9p?5password?7?7?3the?5password?5to?5be@ DB '-p passw'
	DB	'ord', 09H, 09H, ':the password to be used for encryption [def'
	DB	'ault=''password'']', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GOFFCHFO@?9d?5filename?7?7?3decrypt?5the?5specif@
CONST	SEGMENT
??_C@_0CK@GOFFCHFO@?9d?5filename?7?7?3decrypt?5the?5specif@ DB '-d filena'
	DB	'me', 09H, 09H, ':decrypt the specified file', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PGOBLBKL@?9e?5filename?7?7?3encrypt?5the?5specif@
CONST	SEGMENT
??_C@_0CK@PGOBLBKL@?9e?5filename?7?7?3encrypt?5the?5specif@ DB '-e filena'
	DB	'me', 09H, 09H, ':encrypt the specified file', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@BJGDLACJ@?$CFs?5?9d?5?$DMmessage_filename?$DO?5?9k?5?$DMkey@
CONST	SEGMENT
??_C@_0EF@BJGDLACJ@?$CFs?5?9d?5?$DMmessage_filename?$DO?5?9k?5?$DMkey@ DB '%'
	DB	's -d <message_filename> -k <keyfile> -p <password> [-r <#roun'
	DB	'ds>]', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDGFJOJO@To?5Decrypt?3?6?$AA@
CONST	SEGMENT
??_C@_0N@KDGFJOJO@To?5Decrypt?3?6?$AA@ DB 'To Decrypt:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@JJIJOCMP@?$CFs?5?9e?5?$DMmessage_filename?$DO?5?9k?5?$DMkey@
CONST	SEGMENT
??_C@_0EF@JJIJOCMP@?$CFs?5?9e?5?$DMmessage_filename?$DO?5?9k?5?$DMkey@ DB '%'
	DB	's -e <message_filename> -k <keyfile> -p <password> [-r <#roun'
	DB	'ds>]', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOPCGLHN@To?5Encrypt?3?6?$AA@
CONST	SEGMENT
??_C@_0N@MOPCGLHN@To?5Encrypt?3?6?$AA@ DB 'To Encrypt:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HKODOBAD@?6?6Usage?3?6?6?$AA@
CONST	SEGMENT
??_C@_0L@HKODOBAD@?6?6Usage?3?6?6?$AA@ DB 0aH, 0aH, 'Usage:', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DAJOHFLE@?6?6Error?5?9?5Could?5not?5open?5output?5@
CONST	SEGMENT
??_C@_0CL@DAJOHFLE@?6?6Error?5?9?5Could?5not?5open?5output?5@ DB 0aH, 0aH
	DB	'Error - Could not open output file %s!', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BFHAFKOB@wb?$CL?$AA@
CONST	SEGMENT
??_C@_03BFHAFKOB@wb?$CL?$AA@ DB 'wb+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CDMOMEJ@?6?6Error?5?9?5Could?5not?5open?5input?5f@
CONST	SEGMENT
??_C@_0CK@CDMOMEJ@?6?6Error?5?9?5Could?5not?5open?5input?5f@ DB 0aH, 0aH, 'E'
	DB	'rror - Could not open input file %s!', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5by@
CONST	SEGMENT
??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5by@ DB 'Error '
	DB	'- Could not allocate %d bytes of memory on the heap.', 0aH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JAEAEOCO@Error?5?9?5Input?5file?5too?5large?4?6?6?$AA@
CONST	SEGMENT
??_C@_0CA@JAEAEOCO@Error?5?9?5Input?5file?5too?5large?4?6?6?$AA@ DB 'Erro'
	DB	'r - Input file too large.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\chenj\onedrive\documents\visual studio 2013\projects\team_06_cs3843_project\team_06_cs3843_project\cryptomain_initial.cpp
;	COMDAT _main
_TEXT	SEGMENT
_resulti$ = -20						; size = 4
_length$ = -8						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 439  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 440  : #ifdef TEST_CODE
; 441  : 	char testData[] = "The big lazy brown FOX jumped 123 the 987 dog. Then he 8 a CHICKEN.";
; 442  : 	int numCAPS, numLow, numNonLetters;
; 443  : 	numCAPS = numLow = numNonLetters = 0;
; 444  : 	exCountLetters(testData, strlen(testData), &numCAPS, &numLow, &numNonLetters);
; 445  : 	printf("numCAPS=%d, numLow=%d, numNonLetters=%d\n", numCAPS, numLow, numNonLetters );
; 446  : 	exit(0);
; 447  : #endif
; 448  : 
; 449  : 	int length, resulti;
; 450  : 
; 451  : 	fprintf(stdout, "\n\nCrypto Order:%s\n\n", CRYPTO_ORDER);

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_06LPALFHPD@ABCDE?$AA?$AA@
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@ILNEECEA@?6?6Crypto?5Order?3?$CFs?6?6?$AA@
  00028	e8 00 00 00 00	 call	 ___iob_func
  0002d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00032	c1 e1 00	 shl	 ecx, 0
  00035	03 c1		 add	 eax, ecx
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _fprintf
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 452  : 
; 453  : 	// parse command line parameters
; 454  : 	parseCommandLine(argc, argv);		// sets global variables, checks input options for errors

  00040	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00043	50		 push	 eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _argc$[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ?parseCommandLine@@YAXHQAPAD@Z ; parseCommandLine
  0004d	83 c4 08	 add	 esp, 8

; 455  : 
; 456  : 	// open the input and output files
; 457  : 	gfptrIn = openInputFile(gInFileName);

  00050	68 00 00 00 00	 push	 OFFSET ?gInFileName@@3PADA ; gInFileName
  00055	e8 00 00 00 00	 call	 ?openInputFile@@YAPAU_iobuf@@PAD@Z ; openInputFile
  0005a	83 c4 04	 add	 esp, 4
  0005d	a3 00 00 00 00	 mov	 DWORD PTR ?gfptrIn@@3PAU_iobuf@@A, eax ; gfptrIn

; 458  : 	gfptrKey = openInputFile(gKeyFileName);

  00062	68 00 00 00 00	 push	 OFFSET ?gKeyFileName@@3PADA ; gKeyFileName
  00067	e8 00 00 00 00	 call	 ?openInputFile@@YAPAU_iobuf@@PAD@Z ; openInputFile
  0006c	83 c4 04	 add	 esp, 4
  0006f	a3 00 00 00 00	 mov	 DWORD PTR ?gfptrKey@@3PAU_iobuf@@A, eax ; gfptrKey

; 459  : 	gfptrOut = openOutputFile(gOutFileName);

  00074	68 00 00 00 00	 push	 OFFSET ?gOutFileName@@3PADA ; gOutFileName
  00079	e8 00 00 00 00	 call	 ?openOutputFile@@YAPAU_iobuf@@PAD@Z ; openOutputFile
  0007e	83 c4 04	 add	 esp, 4
  00081	a3 00 00 00 00	 mov	 DWORD PTR ?gfptrOut@@3PAU_iobuf@@A, eax ; gfptrOut

; 460  : 
; 461  : 	length = (size_t) strlen(gPassword);

  00086	68 00 00 00 00	 push	 OFFSET ?gPassword@@3PADA ; gPassword
  0008b	e8 00 00 00 00	 call	 _strlen
  00090	83 c4 04	 add	 esp, 4
  00093	89 45 f8	 mov	 DWORD PTR _length$[ebp], eax

; 462  : 
; 463  : 	resulti = sha256(NULL, gPassword, length, gPasswordHash);		// get sha-256 hash of password

  00096	68 00 00 00 00	 push	 OFFSET ?gPasswordHash@@3PAEA ; gPasswordHash
  0009b	8b 45 f8	 mov	 eax, DWORD PTR _length$[ebp]
  0009e	50		 push	 eax
  0009f	68 00 00 00 00	 push	 OFFSET ?gPassword@@3PADA ; gPassword
  000a4	6a 00		 push	 0
  000a6	e8 00 00 00 00	 call	 ?sha256@@YAHPAD0KQAE@Z	; sha256
  000ab	83 c4 10	 add	 esp, 16			; 00000010H
  000ae	89 45 ec	 mov	 DWORD PTR _resulti$[ebp], eax

; 464  : 	if(resulti != 0)

  000b1	83 7d ec 00	 cmp	 DWORD PTR _resulti$[ebp], 0
  000b5	74 23		 je	 SHORT $LN4@main

; 465  : 	{
; 466  : 		fprintf(stderr, "Error! Password not hashed correctly.\n\n");

  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KLALAHPJ@Error?$CB?5Password?5not?5hashed?5corre@
  000bc	e8 00 00 00 00	 call	 ___iob_func
  000c1	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000c6	d1 e1		 shl	 ecx, 1
  000c8	03 c1		 add	 eax, ecx
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _fprintf
  000d0	83 c4 08	 add	 esp, 8

; 467  : 		exit(-1);

  000d3	6a ff		 push	 -1
  000d5	e8 00 00 00 00	 call	 _exit
$LN4@main:

; 468  : 	}
; 469  : 
; 470  : 	length = fread(gkey, 1, 65537, gfptrKey);

  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gfptrKey@@3PAU_iobuf@@A ; gfptrKey
  000df	50		 push	 eax
  000e0	68 01 00 01 00	 push	 65537			; 00010001H
  000e5	6a 01		 push	 1
  000e7	68 00 00 00 00	 push	 OFFSET ?gkey@@3PAEA	; gkey
  000ec	e8 00 00 00 00	 call	 _fread
  000f1	83 c4 10	 add	 esp, 16			; 00000010H
  000f4	89 45 f8	 mov	 DWORD PTR _length$[ebp], eax

; 471  : 	if(length != 65537)

  000f7	81 7d f8 01 00
	01 00		 cmp	 DWORD PTR _length$[ebp], 65537 ; 00010001H
  000fe	74 23		 je	 SHORT $LN3@main

; 472  : 	{
; 473  : 		fprintf(stderr, "Error! Length of key file is not at least 65537.\n\n");

  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@EONHCAAK@Error?$CB?5Length?5of?5key?5file?5is?5not@
  00105	e8 00 00 00 00	 call	 ___iob_func
  0010a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0010f	d1 e1		 shl	 ecx, 1
  00111	03 c1		 add	 eax, ecx
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 _fprintf
  00119	83 c4 08	 add	 esp, 8

; 474  : 		exit(-1);

  0011c	6a ff		 push	 -1
  0011e	e8 00 00 00 00	 call	 _exit
$LN3@main:

; 475  : 	}
; 476  : 	fclose(gfptrKey);

  00123	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gfptrKey@@3PAU_iobuf@@A ; gfptrKey
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _fclose
  0012e	83 c4 04	 add	 esp, 4

; 477  : 	gfptrKey = NULL;

  00131	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gfptrKey@@3PAU_iobuf@@A, 0 ; gfptrKey

; 478  : 
; 479  : 	if(gOp == 1)	// encrypt

  0013b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gOp@@3HA, 1	; gOp
  00142	75 17		 jne	 SHORT $LN2@main

; 480  : 	{
; 481  : 		encryptFile(gfptrIn, gfptrOut);

  00144	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gfptrOut@@3PAU_iobuf@@A ; gfptrOut
  00149	50		 push	 eax
  0014a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gfptrIn@@3PAU_iobuf@@A ; gfptrIn
  00150	51		 push	 ecx
  00151	e8 00 00 00 00	 call	 ?encryptFile@@YAHPAU_iobuf@@0@Z ; encryptFile
  00156	83 c4 08	 add	 esp, 8

; 482  : 	}
; 483  : 	else

  00159	eb 15		 jmp	 SHORT $LN1@main
$LN2@main:

; 484  : 	{
; 485  : 		decryptFile(gfptrIn, gfptrOut);

  0015b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gfptrOut@@3PAU_iobuf@@A ; gfptrOut
  00160	50		 push	 eax
  00161	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gfptrIn@@3PAU_iobuf@@A ; gfptrIn
  00167	51		 push	 ecx
  00168	e8 00 00 00 00	 call	 ?decryptFile@@YAHPAU_iobuf@@0@Z ; decryptFile
  0016d	83 c4 08	 add	 esp, 8
$LN1@main:

; 486  : 	}
; 487  : 
; 488  : 	fclose(gfptrIn);

  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gfptrIn@@3PAU_iobuf@@A ; gfptrIn
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 _fclose
  0017b	83 c4 04	 add	 esp, 4

; 489  : 	fclose(gfptrOut);

  0017e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gfptrOut@@3PAU_iobuf@@A ; gfptrOut
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 _fclose
  00189	83 c4 04	 add	 esp, 4

; 490  : 	return;
; 491  : } // main

  0018c	eb 02		 jmp	 SHORT $LN8@main
$LN6@main:
  0018e	eb 02		 jmp	 SHORT $LN7@main
$LN8@main:
  00190	33 c0		 xor	 eax, eax
$LN7@main:
  00192	5f		 pop	 edi
  00193	5e		 pop	 esi
  00194	5b		 pop	 ebx
  00195	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0019b	3b ec		 cmp	 ebp, esp
  0019d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\chenj\onedrive\documents\visual studio 2013\projects\team_06_cs3843_project\team_06_cs3843_project\cryptomain_initial.cpp
;	COMDAT ?parseCommandLine@@YAXHQAPAD@Z
_TEXT	SEGMENT
_x$1 = -92						; size = 4
_err_flag$ = -77					; size = 1
_p_flag$ = -65						; size = 1
_k_flag$ = -53						; size = 1
_o_flag$ = -41						; size = 1
_i_flag$ = -29						; size = 1
_ch$ = -17						; size = 1
_cnt$ = -8						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
?parseCommandLine@@YAXHQAPAD@Z PROC			; parseCommandLine, COMDAT

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00012	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 254  : 	int cnt;
; 255  : 	char ch;
; 256  : 	bool i_flag, o_flag, k_flag, p_flag, err_flag;
; 257  : 
; 258  : 	i_flag = k_flag = false;				// these must be true in order to exit this function

  0001e	c6 45 cb 00	 mov	 BYTE PTR _k_flag$[ebp], 0
  00022	8a 45 cb	 mov	 al, BYTE PTR _k_flag$[ebp]
  00025	88 45 e3	 mov	 BYTE PTR _i_flag$[ebp], al

; 259  : 	err_flag = p_flag = o_flag = false;		// these will generate different actions

  00028	c6 45 d7 00	 mov	 BYTE PTR _o_flag$[ebp], 0
  0002c	8a 45 d7	 mov	 al, BYTE PTR _o_flag$[ebp]
  0002f	88 45 bf	 mov	 BYTE PTR _p_flag$[ebp], al
  00032	8a 4d bf	 mov	 cl, BYTE PTR _p_flag$[ebp]
  00035	88 4d b3	 mov	 BYTE PTR _err_flag$[ebp], cl

; 260  : 
; 261  : 	cnt = 1;	// skip program name

  00038	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _cnt$[ebp], 1
$LN46@parseComma:

; 262  : 	while(cnt < argc)

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00042	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  00045	0f 8d 93 04 00
	00		 jge	 $LN45@parseComma

; 263  : 	{
; 264  : 		ch = *argv[cnt];

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00051	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00054	8a 02		 mov	 al, BYTE PTR [edx]
  00056	88 45 ef	 mov	 BYTE PTR _ch$[ebp], al

; 265  : 		if(ch != '-')

  00059	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  0005d	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00060	74 28		 je	 SHORT $LN44@parseComma

; 266  : 		{
; 267  : 			fprintf(stderr, "All options must be preceeded by a dash '-'\n\n");

  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@BHBEBKEC@All?5options?5must?5be?5preceeded?5by@
  00067	e8 00 00 00 00	 call	 ___iob_func
  0006c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00071	d1 e1		 shl	 ecx, 1
  00073	03 c1		 add	 eax, ecx
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _fprintf
  0007b	83 c4 08	 add	 esp, 8

; 268  : 			usage(argv);

  0007e	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  00087	83 c4 04	 add	 esp, 4
$LN44@parseComma:

; 269  : 		}
; 270  : 
; 271  : 		ch = *(argv[cnt]+1);

  0008a	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  0008d	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00090	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00093	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00096	88 45 ef	 mov	 BYTE PTR _ch$[ebp], al

; 272  : 		if(0)

  00099	33 c0		 xor	 eax, eax
  0009b	74 05		 je	 SHORT $LN43@parseComma
  0009d	e9 2e 04 00 00	 jmp	 $LN42@parseComma
$LN43@parseComma:

; 273  : 		{
; 274  : 		}
; 275  : 
; 276  : 		else if(ch == 'e' || ch == 'E')

  000a2	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  000a6	83 f8 65	 cmp	 eax, 101		; 00000065H
  000a9	74 0d		 je	 SHORT $LN40@parseComma
  000ab	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  000af	83 f8 45	 cmp	 eax, 69			; 00000045H
  000b2	0f 85 a2 00 00
	00		 jne	 $LN41@parseComma
$LN40@parseComma:

; 277  : 		{
; 278  : 			if(i_flag == true || gOp != 0)

  000b8	0f b6 45 e3	 movzx	 eax, BYTE PTR _i_flag$[ebp]
  000bc	83 f8 01	 cmp	 eax, 1
  000bf	74 09		 je	 SHORT $LN38@parseComma
  000c1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gOp@@3HA, 0	; gOp
  000c8	74 28		 je	 SHORT $LN39@parseComma
$LN38@parseComma:

; 279  : 			{
; 280  : 				fprintf(stderr, "Error! Already specifed an input file - can't encrypt/decrypt multiple files.\n\n");

  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@LMDBBGLK@Error?$CB?5Already?5specifed?5an?5input@
  000cf	e8 00 00 00 00	 call	 ___iob_func
  000d4	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000d9	d1 e1		 shl	 ecx, 1
  000db	03 c1		 add	 eax, ecx
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _fprintf
  000e3	83 c4 08	 add	 esp, 8

; 281  : 				usage(argv);

  000e6	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  000ef	83 c4 04	 add	 esp, 4
$LN39@parseComma:

; 282  : 			}
; 283  : 
; 284  : 			i_flag = true;

  000f2	c6 45 e3 01	 mov	 BYTE PTR _i_flag$[ebp], 1

; 285  : 			cnt++;

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  000f9	83 c0 01	 add	 eax, 1
  000fc	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 286  : 			if(cnt >= argc)

  000ff	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00102	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  00105	7c 28		 jl	 SHORT $LN37@parseComma

; 287  : 			{
; 288  : 				fprintf(stderr, "Error! Must specify a filename after '-e'\n\n");

  00107	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@IFNFECJC@Error?$CB?5Must?5specify?5a?5filename?5a@
  0010c	e8 00 00 00 00	 call	 ___iob_func
  00111	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00116	d1 e1		 shl	 ecx, 1
  00118	03 c1		 add	 eax, ecx
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 _fprintf
  00120	83 c4 08	 add	 esp, 8

; 289  : 				usage(argv);

  00123	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  0012c	83 c4 04	 add	 esp, 4
$LN37@parseComma:

; 290  : 			}
; 291  : 
; 292  : 			strncpy(gInFileName, argv[cnt], 256);

  0012f	68 00 01 00 00	 push	 256			; 00000100H
  00134	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00137	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  0013a	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0013d	52		 push	 edx
  0013e	68 00 00 00 00	 push	 OFFSET ?gInFileName@@3PADA ; gInFileName
  00143	e8 00 00 00 00	 call	 _strncpy
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH

; 293  : 			gOp = 1;	// encrypt

  0014b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gOp@@3HA, 1	; gOp
  00155	e9 76 03 00 00	 jmp	 $LN42@parseComma
$LN41@parseComma:

; 294  : 		}
; 295  : 
; 296  : 		else if(ch == 'd' || ch == 'D')

  0015a	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  0015e	83 f8 64	 cmp	 eax, 100		; 00000064H
  00161	74 0d		 je	 SHORT $LN34@parseComma
  00163	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  00167	83 f8 44	 cmp	 eax, 68			; 00000044H
  0016a	0f 85 a2 00 00
	00		 jne	 $LN35@parseComma
$LN34@parseComma:

; 297  : 		{
; 298  : 			if(i_flag == true || gOp != 0)

  00170	0f b6 45 e3	 movzx	 eax, BYTE PTR _i_flag$[ebp]
  00174	83 f8 01	 cmp	 eax, 1
  00177	74 09		 je	 SHORT $LN32@parseComma
  00179	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gOp@@3HA, 0	; gOp
  00180	74 28		 je	 SHORT $LN33@parseComma
$LN32@parseComma:

; 299  : 			{
; 300  : 				fprintf(stderr, "Error! Already specifed an input file - can't decrypt/encrypt multiple files.\n\n");

  00182	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@FBLKPEDD@Error?$CB?5Already?5specifed?5an?5input@
  00187	e8 00 00 00 00	 call	 ___iob_func
  0018c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00191	d1 e1		 shl	 ecx, 1
  00193	03 c1		 add	 eax, ecx
  00195	50		 push	 eax
  00196	e8 00 00 00 00	 call	 _fprintf
  0019b	83 c4 08	 add	 esp, 8

; 301  : 				usage(argv);

  0019e	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  001a1	50		 push	 eax
  001a2	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  001a7	83 c4 04	 add	 esp, 4
$LN33@parseComma:

; 302  : 			}
; 303  : 
; 304  : 			i_flag = true;

  001aa	c6 45 e3 01	 mov	 BYTE PTR _i_flag$[ebp], 1

; 305  : 			cnt++;

  001ae	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  001b1	83 c0 01	 add	 eax, 1
  001b4	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 306  : 			if(cnt >= argc)

  001b7	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  001ba	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  001bd	7c 28		 jl	 SHORT $LN31@parseComma

; 307  : 			{
; 308  : 				fprintf(stderr, "Error! Must specify a filename after '-d'\n\n");

  001bf	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LILFGLCC@Error?$CB?5Must?5specify?5a?5filename?5a@
  001c4	e8 00 00 00 00	 call	 ___iob_func
  001c9	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001ce	d1 e1		 shl	 ecx, 1
  001d0	03 c1		 add	 eax, ecx
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 _fprintf
  001d8	83 c4 08	 add	 esp, 8

; 309  : 				usage(argv);

  001db	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  001de	50		 push	 eax
  001df	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  001e4	83 c4 04	 add	 esp, 4
$LN31@parseComma:

; 310  : 			}
; 311  : 
; 312  : 			strncpy(gInFileName, argv[cnt], 256);

  001e7	68 00 01 00 00	 push	 256			; 00000100H
  001ec	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  001ef	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  001f2	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  001f5	52		 push	 edx
  001f6	68 00 00 00 00	 push	 OFFSET ?gInFileName@@3PADA ; gInFileName
  001fb	e8 00 00 00 00	 call	 _strncpy
  00200	83 c4 0c	 add	 esp, 12			; 0000000cH

; 313  : 			gOp = 2;	// decrypt

  00203	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?gOp@@3HA, 2	; gOp
  0020d	e9 be 02 00 00	 jmp	 $LN42@parseComma
$LN35@parseComma:

; 314  : 		}
; 315  : 
; 316  : 		else if(ch == 'o' || ch == 'O')

  00212	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  00216	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  00219	74 0d		 je	 SHORT $LN28@parseComma
  0021b	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  0021f	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  00222	0f 85 8f 00 00
	00		 jne	 $LN29@parseComma
$LN28@parseComma:

; 317  : 		{
; 318  : 			if(o_flag == true)

  00228	0f b6 45 d7	 movzx	 eax, BYTE PTR _o_flag$[ebp]
  0022c	83 f8 01	 cmp	 eax, 1
  0022f	75 28		 jne	 SHORT $LN27@parseComma

; 319  : 			{
; 320  : 				fprintf(stderr, "Error! Already specifed an output file.\n\n");

  00231	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@OMLLAEKC@Error?$CB?5Already?5specifed?5an?5outpu@
  00236	e8 00 00 00 00	 call	 ___iob_func
  0023b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00240	d1 e1		 shl	 ecx, 1
  00242	03 c1		 add	 eax, ecx
  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 _fprintf
  0024a	83 c4 08	 add	 esp, 8

; 321  : 				usage(argv);

  0024d	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00250	50		 push	 eax
  00251	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  00256	83 c4 04	 add	 esp, 4
$LN27@parseComma:

; 322  : 			}
; 323  : 			o_flag = true;

  00259	c6 45 d7 01	 mov	 BYTE PTR _o_flag$[ebp], 1

; 324  : 			cnt++;

  0025d	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00260	83 c0 01	 add	 eax, 1
  00263	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 325  : 			if(cnt >= argc)

  00266	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00269	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  0026c	7c 28		 jl	 SHORT $LN26@parseComma

; 326  : 			{
; 327  : 				fprintf(stderr, "Error! Must specify a filename after '-o'\n\n");

  0026e	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@MPGFFKDD@Error?$CB?5Must?5specify?5a?5filename?5a@
  00273	e8 00 00 00 00	 call	 ___iob_func
  00278	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0027d	d1 e1		 shl	 ecx, 1
  0027f	03 c1		 add	 eax, ecx
  00281	50		 push	 eax
  00282	e8 00 00 00 00	 call	 _fprintf
  00287	83 c4 08	 add	 esp, 8

; 328  : 				usage(argv);

  0028a	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  00293	83 c4 04	 add	 esp, 4
$LN26@parseComma:

; 329  : 			}
; 330  : 			strncpy(gOutFileName, argv[cnt], 256);

  00296	68 00 01 00 00	 push	 256			; 00000100H
  0029b	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  0029e	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  002a1	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  002a4	52		 push	 edx
  002a5	68 00 00 00 00	 push	 OFFSET ?gOutFileName@@3PADA ; gOutFileName
  002aa	e8 00 00 00 00	 call	 _strncpy
  002af	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b2	e9 19 02 00 00	 jmp	 $LN42@parseComma
$LN29@parseComma:

; 331  : 		}
; 332  : 
; 333  : 		else if(ch == 'k' || ch == 'K')

  002b7	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  002bb	83 f8 6b	 cmp	 eax, 107		; 0000006bH
  002be	74 0d		 je	 SHORT $LN23@parseComma
  002c0	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  002c4	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  002c7	0f 85 8f 00 00
	00		 jne	 $LN24@parseComma
$LN23@parseComma:

; 334  : 		{
; 335  : 			if(k_flag == true)

  002cd	0f b6 45 cb	 movzx	 eax, BYTE PTR _k_flag$[ebp]
  002d1	83 f8 01	 cmp	 eax, 1
  002d4	75 28		 jne	 SHORT $LN22@parseComma

; 336  : 			{
; 337  : 				fprintf(stderr, "Error! Already specifed a key file.\n\n");

  002d6	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EICJBIPF@Error?$CB?5Already?5specifed?5a?5key?5fi@
  002db	e8 00 00 00 00	 call	 ___iob_func
  002e0	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  002e5	d1 e1		 shl	 ecx, 1
  002e7	03 c1		 add	 eax, ecx
  002e9	50		 push	 eax
  002ea	e8 00 00 00 00	 call	 _fprintf
  002ef	83 c4 08	 add	 esp, 8

; 338  : 				usage(argv);

  002f2	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  002f5	50		 push	 eax
  002f6	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  002fb	83 c4 04	 add	 esp, 4
$LN22@parseComma:

; 339  : 			}
; 340  : 			k_flag = true;

  002fe	c6 45 cb 01	 mov	 BYTE PTR _k_flag$[ebp], 1

; 341  : 			cnt++;

  00302	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00305	83 c0 01	 add	 eax, 1
  00308	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 342  : 			if(cnt >= argc)

  0030b	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  0030e	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  00311	7c 28		 jl	 SHORT $LN21@parseComma

; 343  : 			{
; 344  : 				fprintf(stderr, "Error! Must specify a filename after '-k'\n\n");

  00313	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@DKOFPMPD@Error?$CB?5Must?5specify?5a?5filename?5a@
  00318	e8 00 00 00 00	 call	 ___iob_func
  0031d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00322	d1 e1		 shl	 ecx, 1
  00324	03 c1		 add	 eax, ecx
  00326	50		 push	 eax
  00327	e8 00 00 00 00	 call	 _fprintf
  0032c	83 c4 08	 add	 esp, 8

; 345  : 				usage(argv);

  0032f	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00332	50		 push	 eax
  00333	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  00338	83 c4 04	 add	 esp, 4
$LN21@parseComma:

; 346  : 			}
; 347  : 			strncpy(gKeyFileName, argv[cnt], 256);

  0033b	68 00 01 00 00	 push	 256			; 00000100H
  00340	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00343	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00346	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00349	52		 push	 edx
  0034a	68 00 00 00 00	 push	 OFFSET ?gKeyFileName@@3PADA ; gKeyFileName
  0034f	e8 00 00 00 00	 call	 _strncpy
  00354	83 c4 0c	 add	 esp, 12			; 0000000cH
  00357	e9 74 01 00 00	 jmp	 $LN42@parseComma
$LN24@parseComma:

; 348  : 		}
; 349  : 
; 350  : 		else if(ch == 'p' || ch == 'P')

  0035c	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  00360	83 f8 70	 cmp	 eax, 112		; 00000070H
  00363	74 0d		 je	 SHORT $LN18@parseComma
  00365	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  00369	83 f8 50	 cmp	 eax, 80			; 00000050H
  0036c	0f 85 8f 00 00
	00		 jne	 $LN19@parseComma
$LN18@parseComma:

; 351  : 		{
; 352  : 			if(p_flag == true)

  00372	0f b6 45 bf	 movzx	 eax, BYTE PTR _p_flag$[ebp]
  00376	83 f8 01	 cmp	 eax, 1
  00379	75 28		 jne	 SHORT $LN17@parseComma

; 353  : 			{
; 354  : 				fprintf(stderr, "Error! Already specifed a password.\n\n");

  0037b	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OPKIBCL@Error?$CB?5Already?5specifed?5a?5passwo@
  00380	e8 00 00 00 00	 call	 ___iob_func
  00385	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0038a	d1 e1		 shl	 ecx, 1
  0038c	03 c1		 add	 eax, ecx
  0038e	50		 push	 eax
  0038f	e8 00 00 00 00	 call	 _fprintf
  00394	83 c4 08	 add	 esp, 8

; 355  : 				usage(argv);

  00397	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  0039a	50		 push	 eax
  0039b	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  003a0	83 c4 04	 add	 esp, 4
$LN17@parseComma:

; 356  : 			}
; 357  : 			p_flag = true;

  003a3	c6 45 bf 01	 mov	 BYTE PTR _p_flag$[ebp], 1

; 358  : 			cnt++;

  003a7	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  003aa	83 c0 01	 add	 eax, 1
  003ad	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 359  : 			if(cnt >= argc)

  003b0	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  003b3	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  003b6	7c 28		 jl	 SHORT $LN16@parseComma

; 360  : 			{
; 361  : 				fprintf(stderr, "Error! Must enter a password after '-p'\n\n");

  003b8	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@LDPPFIPG@Error?$CB?5Must?5enter?5a?5password?5aft@
  003bd	e8 00 00 00 00	 call	 ___iob_func
  003c2	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  003c7	d1 e1		 shl	 ecx, 1
  003c9	03 c1		 add	 eax, ecx
  003cb	50		 push	 eax
  003cc	e8 00 00 00 00	 call	 _fprintf
  003d1	83 c4 08	 add	 esp, 8

; 362  : 				usage(argv);

  003d4	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  003d7	50		 push	 eax
  003d8	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  003dd	83 c4 04	 add	 esp, 4
$LN16@parseComma:

; 363  : 			}
; 364  : 			strncpy(gPassword, argv[cnt], 256);

  003e0	68 00 01 00 00	 push	 256			; 00000100H
  003e5	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  003e8	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  003eb	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  003ee	52		 push	 edx
  003ef	68 00 00 00 00	 push	 OFFSET ?gPassword@@3PADA ; gPassword
  003f4	e8 00 00 00 00	 call	 _strncpy
  003f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  003fc	e9 cf 00 00 00	 jmp	 $LN42@parseComma
$LN19@parseComma:

; 365  : 		}
; 366  : 
; 367  : 		else if(ch == 'r' || ch == 'R')

  00401	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  00405	83 f8 72	 cmp	 eax, 114		; 00000072H
  00408	74 0d		 je	 SHORT $LN13@parseComma
  0040a	0f be 45 ef	 movsx	 eax, BYTE PTR _ch$[ebp]
  0040e	83 f8 52	 cmp	 eax, 82			; 00000052H
  00411	0f 85 87 00 00
	00		 jne	 $LN14@parseComma
$LN13@parseComma:

; 368  : 		{
; 369  : 			int x;
; 370  : 
; 371  : 			cnt++;

  00417	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  0041a	83 c0 01	 add	 eax, 1
  0041d	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 372  : 			if(cnt >= argc)

  00420	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00423	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  00426	7c 28		 jl	 SHORT $LN12@parseComma

; 373  : 			{
; 374  : 				fprintf(stderr, "Error! Must enter number between 1 and 3 after '-r'\n\n");

  00428	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@KLPKKKEI@Error?$CB?5Must?5enter?5number?5between@
  0042d	e8 00 00 00 00	 call	 ___iob_func
  00432	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00437	d1 e1		 shl	 ecx, 1
  00439	03 c1		 add	 eax, ecx
  0043b	50		 push	 eax
  0043c	e8 00 00 00 00	 call	 _fprintf
  00441	83 c4 08	 add	 esp, 8

; 375  : 				usage(argv);

  00444	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00447	50		 push	 eax
  00448	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  0044d	83 c4 04	 add	 esp, 4
$LN12@parseComma:

; 376  : 			}
; 377  : 			x = atoi(argv[cnt]);

  00450	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  00453	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00456	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00459	52		 push	 edx
  0045a	e8 00 00 00 00	 call	 _atoi
  0045f	83 c4 04	 add	 esp, 4
  00462	89 45 a4	 mov	 DWORD PTR _x$1[ebp], eax

; 378  : 			if(x < 1 || x > 3)

  00465	83 7d a4 01	 cmp	 DWORD PTR _x$1[ebp], 1
  00469	7c 06		 jl	 SHORT $LN10@parseComma
  0046b	83 7d a4 03	 cmp	 DWORD PTR _x$1[ebp], 3
  0046f	7e 23		 jle	 SHORT $LN11@parseComma
$LN10@parseComma:

; 379  : 			{
; 380  : 				fprintf(stderr, "Warning! Entered bad value for number of rounds. Setting it to one.\n\n");

  00471	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@DAMCJAK@Warning?$CB?5Entered?5bad?5value?5for?5n@
  00476	e8 00 00 00 00	 call	 ___iob_func
  0047b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00480	d1 e1		 shl	 ecx, 1
  00482	03 c1		 add	 eax, ecx
  00484	50		 push	 eax
  00485	e8 00 00 00 00	 call	 _fprintf
  0048a	83 c4 08	 add	 esp, 8

; 381  : 				x = 1;

  0048d	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _x$1[ebp], 1
$LN11@parseComma:

; 382  : 			}
; 383  : 			gNumRounds = x;

  00494	8b 45 a4	 mov	 eax, DWORD PTR _x$1[ebp]
  00497	a3 00 00 00 00	 mov	 DWORD PTR ?gNumRounds@@3HA, eax ; gNumRounds

; 384  : 		}
; 385  : 
; 386  : 		else

  0049c	eb 32		 jmp	 SHORT $LN42@parseComma
$LN14@parseComma:

; 387  : 		{
; 388  : 			fprintf(stderr, "Error! Illegal option in argument. %s\n\n", argv[cnt]);

  0049e	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  004a1	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  004a4	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  004a7	52		 push	 edx
  004a8	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KGFPEMBM@Error?$CB?5Illegal?5option?5in?5argumen@
  004ad	e8 00 00 00 00	 call	 ___iob_func
  004b2	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  004b7	d1 e1		 shl	 ecx, 1
  004b9	03 c1		 add	 eax, ecx
  004bb	50		 push	 eax
  004bc	e8 00 00 00 00	 call	 _fprintf
  004c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 389  : 			usage(argv);

  004c4	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  004c7	50		 push	 eax
  004c8	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  004cd	83 c4 04	 add	 esp, 4
$LN42@parseComma:

; 390  : 		}
; 391  : 
; 392  : 		cnt++;

  004d0	8b 45 f8	 mov	 eax, DWORD PTR _cnt$[ebp]
  004d3	83 c0 01	 add	 eax, 1
  004d6	89 45 f8	 mov	 DWORD PTR _cnt$[ebp], eax

; 393  : 	} // end while

  004d9	e9 61 fb ff ff	 jmp	 $LN46@parseComma
$LN45@parseComma:

; 394  : 
; 395  : 	if(gOp == 0)

  004de	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gOp@@3HA, 0	; gOp
  004e5	75 20		 jne	 SHORT $LN8@parseComma

; 396  : 	{
; 397  : 		fprintf(stderr, "Error! Encrypt or Decrypt must be specified.\n\n)");

  004e7	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@HLBMPEJP@Error?$CB?5Encrypt?5or?5Decrypt?5must?5b@
  004ec	e8 00 00 00 00	 call	 ___iob_func
  004f1	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  004f6	d1 e1		 shl	 ecx, 1
  004f8	03 c1		 add	 eax, ecx
  004fa	50		 push	 eax
  004fb	e8 00 00 00 00	 call	 _fprintf
  00500	83 c4 08	 add	 esp, 8

; 398  : 		err_flag = true;

  00503	c6 45 b3 01	 mov	 BYTE PTR _err_flag$[ebp], 1
$LN8@parseComma:

; 399  : 	}
; 400  : 
; 401  : 	if(i_flag == false)

  00507	0f b6 45 e3	 movzx	 eax, BYTE PTR _i_flag$[ebp]
  0050b	85 c0		 test	 eax, eax
  0050d	75 20		 jne	 SHORT $LN7@parseComma

; 402  : 	{
; 403  : 		fprintf(stderr, "Error! No input file specified.\n\n");

  0050f	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GEEGHLPK@Error?$CB?5No?5input?5file?5specified?4?6@
  00514	e8 00 00 00 00	 call	 ___iob_func
  00519	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0051e	d1 e1		 shl	 ecx, 1
  00520	03 c1		 add	 eax, ecx
  00522	50		 push	 eax
  00523	e8 00 00 00 00	 call	 _fprintf
  00528	83 c4 08	 add	 esp, 8

; 404  : 		err_flag = true;

  0052b	c6 45 b3 01	 mov	 BYTE PTR _err_flag$[ebp], 1
$LN7@parseComma:

; 405  : 	}
; 406  : 
; 407  : 	if(k_flag == false)

  0052f	0f b6 45 cb	 movzx	 eax, BYTE PTR _k_flag$[ebp]
  00533	85 c0		 test	 eax, eax
  00535	75 20		 jne	 SHORT $LN6@parseComma

; 408  : 	{
; 409  : 		fprintf(stderr, "Error! No key file specified.\n\n");

  00537	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JJGKKPID@Error?$CB?5No?5key?5file?5specified?4?6?6?$AA@
  0053c	e8 00 00 00 00	 call	 ___iob_func
  00541	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00546	d1 e1		 shl	 ecx, 1
  00548	03 c1		 add	 eax, ecx
  0054a	50		 push	 eax
  0054b	e8 00 00 00 00	 call	 _fprintf
  00550	83 c4 08	 add	 esp, 8

; 410  : 		err_flag = true;

  00553	c6 45 b3 01	 mov	 BYTE PTR _err_flag$[ebp], 1
$LN6@parseComma:

; 411  : 	}
; 412  : 
; 413  : 	if(p_flag == false)

  00557	0f b6 45 bf	 movzx	 eax, BYTE PTR _p_flag$[ebp]
  0055b	85 c0		 test	 eax, eax
  0055d	75 1c		 jne	 SHORT $LN5@parseComma

; 414  : 	{
; 415  : 		fprintf(stderr, "Warning! Using default 'password'.\n\n");

  0055f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NMMOLMAM@Warning?$CB?5Using?5default?5?8password@
  00564	e8 00 00 00 00	 call	 ___iob_func
  00569	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0056e	d1 e1		 shl	 ecx, 1
  00570	03 c1		 add	 eax, ecx
  00572	50		 push	 eax
  00573	e8 00 00 00 00	 call	 _fprintf
  00578	83 c4 08	 add	 esp, 8
$LN5@parseComma:

; 416  : 	}
; 417  : 
; 418  : 	if(o_flag == false && err_flag == false)	// no need to do this if we have errors

  0057b	0f b6 45 d7	 movzx	 eax, BYTE PTR _o_flag$[ebp]
  0057f	85 c0		 test	 eax, eax
  00581	75 50		 jne	 SHORT $LN4@parseComma
  00583	0f b6 45 b3	 movzx	 eax, BYTE PTR _err_flag$[ebp]
  00587	85 c0		 test	 eax, eax
  00589	75 48		 jne	 SHORT $LN4@parseComma

; 419  : 	{
; 420  : 		strcpy(gOutFileName, gInFileName);

  0058b	68 00 00 00 00	 push	 OFFSET ?gInFileName@@3PADA ; gInFileName
  00590	68 00 00 00 00	 push	 OFFSET ?gOutFileName@@3PADA ; gOutFileName
  00595	e8 00 00 00 00	 call	 _strcpy
  0059a	83 c4 08	 add	 esp, 8

; 421  : 		if(gOp == 1)	// encrypt

  0059d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gOp@@3HA, 1	; gOp
  005a4	75 12		 jne	 SHORT $LN3@parseComma

; 422  : 		{
; 423  : 			strcat(gOutFileName, ".enc");

  005a6	68 00 00 00 00	 push	 OFFSET ??_C@_04EHENEAPI@?4enc?$AA@
  005ab	68 00 00 00 00	 push	 OFFSET ?gOutFileName@@3PADA ; gOutFileName
  005b0	e8 00 00 00 00	 call	 _strcat
  005b5	83 c4 08	 add	 esp, 8
$LN3@parseComma:

; 424  : 		}
; 425  : 		if(gOp == 2)	// decrypt

  005b8	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?gOp@@3HA, 2	; gOp
  005bf	75 12		 jne	 SHORT $LN4@parseComma

; 426  : 		{
; 427  : 			strcat(gOutFileName, ".dec");

  005c1	68 00 00 00 00	 push	 OFFSET ??_C@_04PDKEMIHM@?4dec?$AA@
  005c6	68 00 00 00 00	 push	 OFFSET ?gOutFileName@@3PADA ; gOutFileName
  005cb	e8 00 00 00 00	 call	 _strcat
  005d0	83 c4 08	 add	 esp, 8
$LN4@parseComma:

; 428  : 		}
; 429  : 	}
; 430  : 
; 431  : 	if(err_flag)

  005d3	0f b6 45 b3	 movzx	 eax, BYTE PTR _err_flag$[ebp]
  005d7	85 c0		 test	 eax, eax
  005d9	74 0c		 je	 SHORT $LN47@parseComma

; 432  : 	{
; 433  : 		usage(argv);

  005db	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  005de	50		 push	 eax
  005df	e8 00 00 00 00	 call	 ?usage@@YAXQAPAD@Z	; usage
  005e4	83 c4 04	 add	 esp, 4
$LN47@parseComma:

; 434  : 	}
; 435  : 	return;
; 436  : } // parseCommandLine

  005e7	5f		 pop	 edi
  005e8	5e		 pop	 esi
  005e9	5b		 pop	 ebx
  005ea	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  005f0	3b ec		 cmp	 ebp, esp
  005f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005f7	8b e5		 mov	 esp, ebp
  005f9	5d		 pop	 ebp
  005fa	c3		 ret	 0
?parseCommandLine@@YAXHQAPAD@Z ENDP			; parseCommandLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\chenj\onedrive\documents\visual studio 2013\projects\team_06_cs3843_project\team_06_cs3843_project\cryptomain_initial.cpp
;	COMDAT ?usage@@YAXQAPAD@Z
_TEXT	SEGMENT
_argv$ = 8						; size = 4
?usage@@YAXQAPAD@Z PROC					; usage, COMDAT

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 235  : 	printf("\n\nUsage:\n\n");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HKODOBAD@?6?6Usage?3?6?6?$AA@
  00023	e8 00 00 00 00	 call	 _printf
  00028	83 c4 04	 add	 esp, 4

; 236  : 
; 237  : 	printf("To Encrypt:\n");

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MOPCGLHN@To?5Encrypt?3?6?$AA@
  00030	e8 00 00 00 00	 call	 _printf
  00035	83 c4 04	 add	 esp, 4

; 238  : 	printf("%s -e <message_filename> -k <keyfile> -p <password> [-r <#rounds>]\n\n", argv[0]);

  00038	b8 04 00 00 00	 mov	 eax, 4
  0003d	6b c8 00	 imul	 ecx, eax, 0
  00040	8b 55 08	 mov	 edx, DWORD PTR _argv$[ebp]
  00043	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00046	50		 push	 eax
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@JJIJOCMP@?$CFs?5?9e?5?$DMmessage_filename?$DO?5?9k?5?$DMkey@
  0004c	e8 00 00 00 00	 call	 _printf
  00051	83 c4 08	 add	 esp, 8

; 239  : 
; 240  : 	printf("To Decrypt:\n");

  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KDGFJOJO@To?5Decrypt?3?6?$AA@
  00059	e8 00 00 00 00	 call	 _printf
  0005e	83 c4 04	 add	 esp, 4

; 241  : 	printf("%s -d <message_filename> -k <keyfile> -p <password> [-r <#rounds>]\n\n", argv[0]);

  00061	b8 04 00 00 00	 mov	 eax, 4
  00066	6b c8 00	 imul	 ecx, eax, 0
  00069	8b 55 08	 mov	 edx, DWORD PTR _argv$[ebp]
  0006c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0006f	50		 push	 eax
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@BJGDLACJ@?$CFs?5?9d?5?$DMmessage_filename?$DO?5?9k?5?$DMkey@
  00075	e8 00 00 00 00	 call	 _printf
  0007a	83 c4 08	 add	 esp, 8

; 242  : 
; 243  : 	printf("-e filename		:encrypt the specified file\n");

  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PGOBLBKL@?9e?5filename?7?7?3encrypt?5the?5specif@
  00082	e8 00 00 00 00	 call	 _printf
  00087	83 c4 04	 add	 esp, 4

; 244  : 	printf("-d filename		:decrypt the specified file\n");

  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@GOFFCHFO@?9d?5filename?7?7?3decrypt?5the?5specif@
  0008f	e8 00 00 00 00	 call	 _printf
  00094	83 c4 04	 add	 esp, 4

; 245  : 	printf("-p password		:the password to be used for encryption [default='password']\n");

  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@OBNDFCCB@?9p?5password?7?7?3the?5password?5to?5be@
  0009c	e8 00 00 00 00	 call	 _printf
  000a1	83 c4 04	 add	 esp, 4

; 246  : 	printf("-r <#rounds>		:number of encryption rounds (1 - 3)  [default = 1]\n");

  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@MAGAAIDD@?9r?5?$DM?$CDrounds?$DO?7?7?3number?5of?5encrypt@
  000a9	e8 00 00 00 00	 call	 _printf
  000ae	83 c4 04	 add	 esp, 4

; 247  : 	printf("-o filename		:name of the output file [default='encrypted.txt' or 'decrypted.txt'\n\n");

  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@LAODCPP@?9o?5filename?7?7?3name?5of?5the?5output@
  000b6	e8 00 00 00 00	 call	 _printf
  000bb	83 c4 04	 add	 esp, 4

; 248  : 	printf("The order of the options is irrelevant.\n\n");

  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IPLMHCJC@The?5order?5of?5the?5options?5is?5irre@
  000c3	e8 00 00 00 00	 call	 _printf
  000c8	83 c4 04	 add	 esp, 4

; 249  : 	exit(0);

  000cb	6a 00		 push	 0
  000cd	e8 00 00 00 00	 call	 _exit
$LN2@usage:

; 250  : } // usage

  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000db	3b ec		 cmp	 ebp, esp
  000dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
?usage@@YAXQAPAD@Z ENDP					; usage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\chenj\onedrive\documents\visual studio 2013\projects\team_06_cs3843_project\team_06_cs3843_project\cryptomain_initial.cpp
;	COMDAT ?openOutputFile@@YAPAU_iobuf@@PAD@Z
_TEXT	SEGMENT
_fptr$ = -8						; size = 4
_filename$ = 8						; size = 4
?openOutputFile@@YAPAU_iobuf@@PAD@Z PROC		; openOutputFile, COMDAT

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 221  : 	FILE *fptr;
; 222  : 
; 223  : 	fptr = fopen(filename, "wb+");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_03BFHAFKOB@wb?$CL?$AA@
  00023	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _fopen
  0002c	83 c4 08	 add	 esp, 8
  0002f	89 45 f8	 mov	 DWORD PTR _fptr$[ebp], eax

; 224  : 	if(fptr == NULL)

  00032	83 7d f8 00	 cmp	 DWORD PTR _fptr$[ebp], 0
  00036	75 27		 jne	 SHORT $LN1@openOutput

; 225  : 	{
; 226  : 		fprintf(stderr, "\n\nError - Could not open output file %s!\n\n", filename);

  00038	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0003b	50		 push	 eax
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@DAJOHFLE@?6?6Error?5?9?5Could?5not?5open?5output?5@
  00041	e8 00 00 00 00	 call	 ___iob_func
  00046	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0004b	d1 e1		 shl	 ecx, 1
  0004d	03 c1		 add	 eax, ecx
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _fprintf
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 227  : 		exit(-1);

  00058	6a ff		 push	 -1
  0005a	e8 00 00 00 00	 call	 _exit
$LN1@openOutput:

; 228  : 	}
; 229  : 	return fptr;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _fptr$[ebp]
$LN3@openOutput:

; 230  : } // openOutputFile

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?openOutputFile@@YAPAU_iobuf@@PAD@Z ENDP		; openOutputFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\chenj\onedrive\documents\visual studio 2013\projects\team_06_cs3843_project\team_06_cs3843_project\cryptomain_initial.cpp
;	COMDAT ?openInputFile@@YAPAU_iobuf@@PAD@Z
_TEXT	SEGMENT
_fptr$ = -8						; size = 4
_filename$ = 8						; size = 4
?openInputFile@@YAPAU_iobuf@@PAD@Z PROC			; openInputFile, COMDAT

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 208  : 	FILE *fptr;
; 209  : 
; 210  : 	fptr = fopen(filename, "rb");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  00023	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _fopen
  0002c	83 c4 08	 add	 esp, 8
  0002f	89 45 f8	 mov	 DWORD PTR _fptr$[ebp], eax

; 211  : 	if(fptr == NULL)

  00032	83 7d f8 00	 cmp	 DWORD PTR _fptr$[ebp], 0
  00036	75 27		 jne	 SHORT $LN1@openInputF

; 212  : 	{
; 213  : 		fprintf(stderr, "\n\nError - Could not open input file %s!\n\n", filename);

  00038	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0003b	50		 push	 eax
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@CDMOMEJ@?6?6Error?5?9?5Could?5not?5open?5input?5f@
  00041	e8 00 00 00 00	 call	 ___iob_func
  00046	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0004b	d1 e1		 shl	 ecx, 1
  0004d	03 c1		 add	 eax, ecx
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _fprintf
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 214  : 		exit(-1);

  00058	6a ff		 push	 -1
  0005a	e8 00 00 00 00	 call	 _exit
$LN1@openInputF:

; 215  : 	}
; 216  : 	return fptr;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _fptr$[ebp]
$LN3@openInputF:

; 217  : } // openInputFile

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?openInputFile@@YAPAU_iobuf@@PAD@Z ENDP			; openInputFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\chenj\onedrive\documents\visual studio 2013\projects\team_06_cs3843_project\team_06_cs3843_project\cryptomain_initial.cpp
;	COMDAT ?decryptFile@@YAHPAU_iobuf@@0@Z
_TEXT	SEGMENT
_filesize$ = -20					; size = 4
_buffer$ = -8						; size = 4
_fptrIn$ = 8						; size = 4
_fptrOut$ = 12						; size = 4
?decryptFile@@YAHPAU_iobuf@@0@Z PROC			; decryptFile, COMDAT

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 179  : 	char *buffer;
; 180  : 	unsigned int filesize;
; 181  : 
; 182  : 	filesize = _filelength(_fileno(fptrIn));	// Linux???

  0001e	8b 45 08	 mov	 eax, DWORD PTR _fptrIn$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 __fileno
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 __filelength
  00030	83 c4 04	 add	 esp, 4
  00033	89 45 ec	 mov	 DWORD PTR _filesize$[ebp], eax

; 183  : 	if(filesize > 0x1000000)					// 16 MB, file too large

  00036	81 7d ec 00 00
	00 01		 cmp	 DWORD PTR _filesize$[ebp], 16777216 ; 01000000H
  0003d	76 24		 jbe	 SHORT $LN2@decryptFil

; 184  : 	{
; 185  : 		fprintf(stderr, "Error - Input file too large.\n\n");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JAEAEOCO@Error?5?9?5Input?5file?5too?5large?4?6?6?$AA@
  00044	e8 00 00 00 00	 call	 ___iob_func
  00049	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0004e	d1 e1		 shl	 ecx, 1
  00050	03 c1		 add	 eax, ecx
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _fprintf
  00058	83 c4 08	 add	 esp, 8

; 186  : 		return -1;

  0005b	83 c8 ff	 or	 eax, -1
  0005e	e9 84 00 00 00	 jmp	 $LN3@decryptFil
$LN2@decryptFil:

; 187  : 	}
; 188  : 
; 189  : 	// use the password hash to encrypt
; 190  : 	buffer = (char *) malloc(filesize);

  00063	8b 45 ec	 mov	 eax, DWORD PTR _filesize$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	89 45 f8	 mov	 DWORD PTR _buffer$[ebp], eax

; 191  : 	if(buffer == NULL)

  00072	83 7d f8 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00076	75 25		 jne	 SHORT $LN1@decryptFil

; 192  : 	{
; 193  : 		fprintf(stderr, "Error - Could not allocate %d bytes of memory on the heap.\n\n", filesize);

  00078	8b 45 ec	 mov	 eax, DWORD PTR _filesize$[ebp]
  0007b	50		 push	 eax
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5by@
  00081	e8 00 00 00 00	 call	 ___iob_func
  00086	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0008b	d1 e1		 shl	 ecx, 1
  0008d	03 c1		 add	 eax, ecx
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _fprintf
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH

; 194  : 		return -1;

  00098	83 c8 ff	 or	 eax, -1
  0009b	eb 4a		 jmp	 SHORT $LN3@decryptFil
$LN1@decryptFil:

; 195  : 	}
; 196  : 
; 197  : 	fread(buffer, 1, filesize, fptrIn);	// read entire file

  0009d	8b 45 08	 mov	 eax, DWORD PTR _fptrIn$[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d ec	 mov	 ecx, DWORD PTR _filesize$[ebp]
  000a4	51		 push	 ecx
  000a5	6a 01		 push	 1
  000a7	8b 55 f8	 mov	 edx, DWORD PTR _buffer$[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 _fread
  000b0	83 c4 10	 add	 esp, 16			; 00000010H

; 198  : 	decryptData(buffer, filesize);

  000b3	8b 45 ec	 mov	 eax, DWORD PTR _filesize$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 ?decryptData@@YAHPADH@Z	; decryptData
  000c0	83 c4 08	 add	 esp, 8

; 199  : 	fwrite(buffer, 1, filesize, fptrOut);

  000c3	8b 45 0c	 mov	 eax, DWORD PTR _fptrOut$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d ec	 mov	 ecx, DWORD PTR _filesize$[ebp]
  000ca	51		 push	 ecx
  000cb	6a 01		 push	 1
  000cd	8b 55 f8	 mov	 edx, DWORD PTR _buffer$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 _fwrite
  000d6	83 c4 10	 add	 esp, 16			; 00000010H

; 200  : 	free(buffer);

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _buffer$[ebp]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _free
  000e2	83 c4 04	 add	 esp, 4

; 201  : 
; 202  : 	return 0;

  000e5	33 c0		 xor	 eax, eax
$LN3@decryptFil:

; 203  : } // decryptFile

  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx
  000ea	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
?decryptFile@@YAHPAU_iobuf@@0@Z ENDP			; decryptFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\chenj\onedrive\documents\visual studio 2013\projects\team_06_cs3843_project\team_06_cs3843_project\cryptomain_initial.cpp
;	COMDAT ?encryptFile@@YAHPAU_iobuf@@0@Z
_TEXT	SEGMENT
_filesize$ = -20					; size = 4
_buffer$ = -8						; size = 4
_fptrIn$ = 8						; size = 4
_fptrOut$ = 12						; size = 4
?encryptFile@@YAHPAU_iobuf@@0@Z PROC			; encryptFile, COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 149  : 	char *buffer;
; 150  : 	unsigned int filesize;
; 151  : 
; 152  : 	filesize = _filelength(_fileno(fptrIn));	// Linux???

  0001e	8b 45 08	 mov	 eax, DWORD PTR _fptrIn$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 __fileno
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 __filelength
  00030	83 c4 04	 add	 esp, 4
  00033	89 45 ec	 mov	 DWORD PTR _filesize$[ebp], eax

; 153  : 	if(filesize > 0x1000000)					// 16 MB, file too large

  00036	81 7d ec 00 00
	00 01		 cmp	 DWORD PTR _filesize$[ebp], 16777216 ; 01000000H
  0003d	76 24		 jbe	 SHORT $LN2@encryptFil

; 154  : 	{
; 155  : 		fprintf(stderr, "Error - Input file too large.\n\n");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JAEAEOCO@Error?5?9?5Input?5file?5too?5large?4?6?6?$AA@
  00044	e8 00 00 00 00	 call	 ___iob_func
  00049	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0004e	d1 e1		 shl	 ecx, 1
  00050	03 c1		 add	 eax, ecx
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _fprintf
  00058	83 c4 08	 add	 esp, 8

; 156  : 		return -1;

  0005b	83 c8 ff	 or	 eax, -1
  0005e	e9 84 00 00 00	 jmp	 $LN3@encryptFil
$LN2@encryptFil:

; 157  : 	}
; 158  : 
; 159  : 	// use the password hash to encrypt
; 160  : 	buffer = (char *) malloc(filesize);

  00063	8b 45 ec	 mov	 eax, DWORD PTR _filesize$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	89 45 f8	 mov	 DWORD PTR _buffer$[ebp], eax

; 161  : 	if(buffer == NULL)

  00072	83 7d f8 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00076	75 25		 jne	 SHORT $LN1@encryptFil

; 162  : 	{
; 163  : 		fprintf(stderr, "Error - Could not allocate %d bytes of memory on the heap.\n\n", filesize);

  00078	8b 45 ec	 mov	 eax, DWORD PTR _filesize$[ebp]
  0007b	50		 push	 eax
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5by@
  00081	e8 00 00 00 00	 call	 ___iob_func
  00086	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0008b	d1 e1		 shl	 ecx, 1
  0008d	03 c1		 add	 eax, ecx
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _fprintf
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH

; 164  : 		return -1;

  00098	83 c8 ff	 or	 eax, -1
  0009b	eb 4a		 jmp	 SHORT $LN3@encryptFil
$LN1@encryptFil:

; 165  : 	}
; 166  : 
; 167  : 	fread(buffer, 1, filesize, fptrIn);	// read entire file

  0009d	8b 45 08	 mov	 eax, DWORD PTR _fptrIn$[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d ec	 mov	 ecx, DWORD PTR _filesize$[ebp]
  000a4	51		 push	 ecx
  000a5	6a 01		 push	 1
  000a7	8b 55 f8	 mov	 edx, DWORD PTR _buffer$[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 _fread
  000b0	83 c4 10	 add	 esp, 16			; 00000010H

; 168  : 	encryptData(buffer, filesize);

  000b3	8b 45 ec	 mov	 eax, DWORD PTR _filesize$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 ?encryptData@@YAHPADH@Z	; encryptData
  000c0	83 c4 08	 add	 esp, 8

; 169  : 	fwrite(buffer, 1, filesize, fptrOut);

  000c3	8b 45 0c	 mov	 eax, DWORD PTR _fptrOut$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d ec	 mov	 ecx, DWORD PTR _filesize$[ebp]
  000ca	51		 push	 ecx
  000cb	6a 01		 push	 1
  000cd	8b 55 f8	 mov	 edx, DWORD PTR _buffer$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 _fwrite
  000d6	83 c4 10	 add	 esp, 16			; 00000010H

; 170  : 	free(buffer);

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _buffer$[ebp]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _free
  000e2	83 c4 04	 add	 esp, 4

; 171  : 
; 172  : 	return 0;

  000e5	33 c0		 xor	 eax, eax
$LN3@encryptFil:

; 173  : } // encryptFile

  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx
  000ea	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
?encryptFile@@YAHPAU_iobuf@@0@Z ENDP			; encryptFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\chenj\onedrive\documents\visual studio 2013\projects\team_06_cs3843_project\team_06_cs3843_project\cryptomain_initial.cpp
;	COMDAT ?exCountLetters@@YAXPADHPAH11@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_dataLength$ = 12					; size = 4
_numC$ = 16						; size = 4
_numL$ = 20						; size = 4
_numO$ = 24						; size = 4
?exCountLetters@@YAXPADHPAH11@Z PROC			; exCountLetters, COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 69   : 	__asm {
; 70   : 		cld;					// 

  0001e	fc		 cld

; 71   : 		push esi;				// 

  0001f	56		 push	 esi

; 72   : 		push ecx;				// 

  00020	51		 push	 ecx

; 73   : 		push ebx;

  00021	53		 push	 ebx

; 74   : 		mov esi,data;			// 

  00022	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]

; 75   : 		mov ecx, dataLength;	// 

  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _dataLength$[ebp]
$LOOP_X1$3:

; 76   : 
; 77   : LOOP_X1:
; 78   : 		lodsb;					// 

  00028	ac		 lodsb

; 79   : 		mov bl,al				// 

  00029	8a d8		 mov	 bl, al

; 80   : 		push eax;				// 

  0002b	50		 push	 eax

; 81   : 		call isLetter;			// function returns a 1 in al if the character passed in is a letter, otherwise al = 0

  0002c	e8 2b 00 00 00	 call	 $isLetter$4

; 82   : 		add esp,4				// 

  00031	83 c4 04	 add	 esp, 4

; 83   : 		test al,al;				// 

  00034	84 c0		 test	 al, al

; 84   : 		je lbl_OTHER;			// 

  00036	74 16		 je	 SHORT $lbl_OTHER$5

; 85   : 
; 86   : 		mov al,bl				// 

  00038	8a c3		 mov	 al, bl

; 87   : 		and al,0x20;			// already know it's a letter, if al == 0, then CAP

  0003a	24 20		 and	 al, 32			; 00000020H

; 88   : 		je lbl_CAP;

  0003c	74 08		 je	 SHORT $lbl_CAP$6

; 89   : 		
; 90   : 		mov	ebx,numL;			// 

  0003e	8b 5d 14	 mov	 ebx, DWORD PTR _numL$[ebp]

; 91   : 		add [ebx],1;			// 

  00041	80 03 01	 add	 BYTE PTR [ebx], 1

; 92   : 		jmp lbl_NEXT;			// 

  00044	eb 0e		 jmp	 SHORT $lbl_NEXT$7
$lbl_CAP$6:

; 93   : 
; 94   : lbl_CAP:
; 95   : 		mov ebx,numC;			// 

  00046	8b 5d 10	 mov	 ebx, DWORD PTR _numC$[ebp]

; 96   : 		add [ebx],1;			// 

  00049	80 03 01	 add	 BYTE PTR [ebx], 1

; 97   : 		jmp lbl_NEXT;			// 

  0004c	eb 06		 jmp	 SHORT $lbl_NEXT$7
$lbl_OTHER$5:

; 98   : 
; 99   : lbl_OTHER:
; 100  : 		mov ebx,numO			// 

  0004e	8b 5d 18	 mov	 ebx, DWORD PTR _numO$[ebp]

; 101  : 		add [ebx],1				// 

  00051	80 03 01	 add	 BYTE PTR [ebx], 1
$lbl_NEXT$7:

; 102  : lbl_NEXT:
; 103  : 		dec ecx;				// 

  00054	49		 dec	 ecx

; 104  : 		jne LOOP_X1;			// 

  00055	75 d1		 jne	 SHORT $LOOP_X1$3

; 105  : 
; 106  : 		pop ebx;				// 

  00057	5b		 pop	 ebx

; 107  : 		pop ecx;				// 

  00058	59		 pop	 ecx

; 108  : 		pop esi;				// 

  00059	5e		 pop	 esi

; 109  : 		jmp EXIT_C_EXAMPLE;		// let C handle whatever it did upon entering this function

  0005a	eb 25		 jmp	 SHORT $EXIT_C_EXAMPLE$8
$isLetter$4:

; 110  : 
; 111  : isLetter:
; 112  : 		push ebp;				// 

  0005c	55		 push	 ebp

; 113  : 		mov ebp,esp;			// 

  0005d	8b ec		 mov	 ebp, esp

; 114  : 		mov al,[ebp+8];			// 

  0005f	8a 45 08	 mov	 al, BYTE PTR [ebp+8]

; 115  : 		cmp al,0x40;			// 

  00062	3c 40		 cmp	 al, 64			; 00000040H

; 116  : 		ja lbl_CHK_ZU;			// check Uppercase 'Z'

  00064	77 0d		 ja	 SHORT $lbl_CHK_ZU$9
$lbl_RET_FALSE$10:

; 117  : 
; 118  : lbl_RET_FALSE:
; 119  : 		xor eax,eax;			// 

  00066	33 c0		 xor	 eax, eax
$lbl_RET$11:

; 120  : lbl_RET:
; 121  : 		mov esp,ebp;			// 

  00068	8b e5		 mov	 esp, ebp

; 122  : 		pop ebp;				// 

  0006a	5d		 pop	 ebp

; 123  : 		ret;					// 

  0006b	c3		 ret	 0
$lbl_RET_TRUE$12:

; 124  : 
; 125  : lbl_RET_TRUE:
; 126  : 		mov eax,1;				// 

  0006c	b8 01 00 00 00	 mov	 eax, 1

; 127  : 		jmp lbl_RET;			// 

  00071	eb f5		 jmp	 SHORT $lbl_RET$11
$lbl_CHK_ZU$9:

; 128  : 
; 129  : lbl_CHK_ZU:
; 130  : 		cmp al,0x5B;			// 

  00073	3c 5b		 cmp	 al, 91			; 0000005bH

; 131  : 		jb lbl_RET_TRUE;		// 

  00075	72 f5		 jb	 SHORT $lbl_RET_TRUE$12

; 132  : 
; 133  : 		cmp al,0x61;			// 

  00077	3c 61		 cmp	 al, 97			; 00000061H

; 134  : 		jb lbl_RET_FALSE;		// check lowercase 'z'

  00079	72 eb		 jb	 SHORT $lbl_RET_FALSE$10

; 135  : 
; 136  : 		cmp al,0x7A;			// 

  0007b	3c 7a		 cmp	 al, 122			; 0000007aH

; 137  : 		jbe lbl_RET_TRUE;		// 

  0007d	76 ed		 jbe	 SHORT $lbl_RET_TRUE$12

; 138  : 		jmp lbl_RET_FALSE;		// 

  0007f	eb e5		 jmp	 SHORT $lbl_RET_FALSE$10
$EXIT_C_EXAMPLE$8:

; 139  : 
; 140  : 	} // end assembly block
; 141  : 
; 142  : EXIT_C_EXAMPLE:					// 
; 143  : 	return;
; 144  : } // exCountLetters

  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
?exCountLetters@@YAXPADHPAH11@Z ENDP			; exCountLetters
_TEXT	ENDS
END
