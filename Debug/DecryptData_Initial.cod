; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\chenj\OneDrive\Documents\Visual Studio 2013\Projects\Team_06_CS3843_Project\Team_06_CS3843_Project\DecryptData_Initial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?decryptData@@YAHPADH@Z				; decryptData
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?gdebug1@@3EA:BYTE				; gdebug1
EXTRN	?gdebug2@@3EA:BYTE				; gdebug2
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\chenj\onedrive\documents\visual studio 2013\projects\team_06_cs3843_project\team_06_cs3843_project\decryptdata_initial.cpp
;	COMDAT ?decryptData@@YAHPADH@Z
_TEXT	SEGMENT
_resulti$ = -8						; size = 4
_data$ = 8						; size = 4
_dataLength$ = 12					; size = 4
?decryptData@@YAHPADH@Z PROC				; decryptData, COMDAT

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 12   : 	int resulti = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _resulti$[ebp], 0

; 13   : 
; 14   : 	gdebug1 = 0;					// a couple of global variables that could be used for debugging

  00025	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug1@@3EA, 0 ; gdebug1

; 15   : 	gdebug2 = 0;					// also can have a breakpoint in C code

  0002c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug2@@3EA, 0 ; gdebug2

; 16   : 
; 17   : 	// You can not declare any local variables in C, but should use resulti to indicate any errors
; 18   : 	// Set up the stack frame and assign variables in assembly if you need to do so
; 19   : 	// access the parameters BEFORE setting up your own stack frame
; 20   : 	// Also, you cannot use a lot of global variables - work with registers
; 21   : 
; 22   : 	__asm {
; 23   : 		// you will need to reference some of these global variables
; 24   : 		// (gptrPasswordHash or gPasswordHash), (gptrKey or gkey), gNumRounds
; 25   : 
; 26   : 		/* simple example that xors 2nd byte of data with 14th byte in the key file
; 27   : 		lea esi,gkey				// put the ADDRESS of gkey into esi
; 28   : 		mov esi,gptrKey;			// put the ADDRESS of gkey into esi (since *gptrKey = gkey)
; 29   : 
; 30   : 		lea	esi,gPasswordHash		// put ADDRESS of gPasswordHash into esi
; 31   : 		mov esi,gptrPasswordHash	// put ADDRESS of gPasswordHash into esi (since unsigned char *gptrPasswordHash = gPasswordHash)
; 32   : 
; 33   : 		mov al,byte ptr [esi]				// get first byte of password hash
; 34   : 		mov al,byte ptr [esi+4]				// get 5th byte of password hash
; 35   : 		mov ebx,2
; 36   : 		mov al,byte ptr [esi+ebx]			// get 3rd byte of password hash
; 37   : 		mov al,byte ptr [esi+ebx*2]			// get 5th byte of password hash
; 38   : 
; 39   : 		mov ax,word ptr [esi+ebx*2]			// gets 5th and 6th bytes of password hash ( gPasswordHash[4] and gPasswordHash[5] ) into ax
; 40   : 		mov eax,dword ptr [esi+ebx*2]		// gets 4 bytes, as in:  unsigned int X = *( (unsigned int*) &gPasswordHash[4] );
; 41   : 
; 42   : 		mov al,byte ptr [gkey+ebx]			// get's 3rd byte of gkey[] data
; 43   : 
; 44   : 		mov al,byte ptr [gptrKey+ebx]		// THIS IS INCORRECT - will add the address of the gptrKey global variable (NOT the value that gptrKey holds)
; 45   : 
; 46   : 		mov al,byte ptr [esi+0xd];			// access 14th byte in gkey[]: 0, 1, 2 ... d is the 14th byte
; 47   : 		mov edi,data				// Put ADDRESS of first data element into edi
; 48   : 		xor byte ptr [edi+1],al		// Exclusive-or the 2nd byte of data with the 14th element of the keyfile
; 49   : 									// NOTE: Keyfile[14] = 0x21, that value changes the case of a letter and flips the LSB
; 50   : 									// Lowercase "c" = 0x63 becomes capital "B" since 0x63 xor 0x21 = 0x42
; 51   : 		*/
; 52   : 
; 53   : 
; 54   : 		xor ecx, ecx				// reset ecx to 0

  00033	33 c9		 xor	 ecx, ecx
$startOfLoop$3:

; 55   : 	startOfLoop :
; 56   : 		mov edx, data				// moves the address of data into edx

  00035	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]

; 57   : 		add edx, ecx				// add ecx(index) to edx

  00038	03 d1		 add	 edx, ecx

; 58   : 		mov al, byte ptr[edx]		// move the byte at the index(ecx) into al

  0003a	8a 02		 mov	 al, BYTE PTR [edx]

; 59   : 		test al, al					// check if al is null

  0003c	84 c0		 test	 al, al

; 60   : 		je done						// jump out of loop if al is null

  0003e	74 08		 je	 SHORT $done$4

; 61   : 		xor al, 0xFF				// xor al with all 1's

  00040	34 ff		 xor	 al, -1

; 62   : 		inc ecx						// increment ecx(index)

  00042	41		 inc	 ecx

; 63   : 		cmp ecx, dataLength			// check if ecx is lower than dataLength

  00043	3b 4d 0c	 cmp	 ecx, DWORD PTR _dataLength$[ebp]

; 64   : 		jb startOfLoop				// jump to startOfLoop if ecx is lower than dataLength

  00046	72 ed		 jb	 SHORT $startOfLoop$3
$done$4:

; 65   : 	done :
; 66   : 		nop

  00048	90		 npad	 1

; 67   : 	}
; 68   : 
; 69   : 	return resulti;

  00049	8b 45 f8	 mov	 eax, DWORD PTR _resulti$[ebp]

; 70   : } // decryptData

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?decryptData@@YAHPADH@Z ENDP				; decryptData
_TEXT	ENDS
END
